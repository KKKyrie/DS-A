<html>
	<head>
		<title>散列</title>
		<meta charset = "utf-8">
	</head>
	<body>
		<h2>散列使用的数据结构叫散列表</h2>
		<h3>在散列表上插入、删除和取用数据都非常快，但是对于查找操作来说却效率低下。</h3>
		<hr>
		<h3>散列函数</h3>
		<p>将键映射为一个数字，这个数字的范围是0到散列表的长度。</p>
		<p>理想情况下，散列函数会将每个键值映射为一个唯一的数组索引。然而，键的数量是无限的，数组的长度是有限的，一个更现实的目标是让散列函数尽量将键均匀的映射到数组中。</p>
		<p>碰撞：散列函数将两个键映射成同一个值的情况。</p>
		<hr>
		<h3>散列表中的数组究竟有多大？</h3>
		<p>对数组大小常见的限制是：<b>数组长度应该是一个质数。</b></p>
		<hr>
		<h1>HashTable类</h1>
		<code>
			function HashTable(){<br>
				this.table = new Array(137);<br>
				this.simpleHash = simpleHash;//散列函数<br>
				this.showDistro = showDistro;<br>
				this.put = put;<br>
				// this.get = get;<br>
			}<br>
		</code>
		<p>用这个类来表示散列表，包含计算散列值的方法（散列函数），向散列中插入数据的方法，从散列中读取数据的方法，显示散列表中数据分布的方法等</p>
		<hr>
		<h1>选择一个散列函数</h1>
		<h3>散列函数的选择依赖于键值的数据类型</h3>
		<p>整型：最简单的散列函数，以数组的长度对键取余，除留余数法。</p>
		<button onclick="test()">简单的散列函数</button>
		<hr>
		<h1>一个更好的散列函数</h1>
		<p>为了避免碰撞，首先要确保<b>散列表中用来存储数据的数组其大小是个质数</b>。数组的长度应该在100以上，这是为了让数据在三列表中分布的更加均匀。</p>
		<h2>霍纳算法</h2>
		<p>仍然先计算字符串各字符的ASCII码值，不过求和时每次要乘以一个质数。</p>
		<button onclick="testBetter()">更好的散列函数</button>
		<hr>
		<h1>碰撞处理</h1>
		<h2>开链法</h2>
		<p>开链法是指实现散列表的底层数组中，每个数组元素又是一个新的数据结构，比如另一个数组，这样就能存储多个键了。</p>
		<p>使用这种技术，即时两个键散列后的值相同，依然被保存在同样的位置，只不过它们在第二个数组中的位置不一样罢了。</p>
		<h3>实现开链法的方法</h3>
		<h4>在创建存储散列过的键值的数组时，通过调用一个函数创建一个新的空数组，然后将该数组赋给散列表的每个数组元素。</h4>
		<br>
		<h2>线性探测法</h2>
		<p>线性探测法隶属于一种更一般化的散列技术：<i>开放寻址散列</i></p>
		<h4>发生碰撞时。检查散列表中的下一个位置是否为空。如果为空，就将数据存入该位置；如果不为空，则继续检查下一个位置，直到找到一个空的位置为止。</h4>
		<h3>该技术基于这样一个事实：每个散列表都会有很多空的单元格，可以用它们来存储数据。</h3>
		<hr>
		<h2>当存储数据使用的数组特别大时，线性探测法要比开链法好</h2>
		<h1>如果数组的大小是待存储数据个数的1.5倍，用开链法；若是两倍及两倍以上时，用线性探测法</h1>




		<script type="text/javascript" src="hashTable.js"></script>
	</body>
</html>